# 🎠놀이공원 티켓 구매 사이트 프로젝트

## 프로젝트 소개

이 프로젝트는 놀이공원 내에 위치한 인기 동물원 판다월드의 입장권 구매 요청이 **특정 시간대에 폭증하는 상황**을 가정하여 설계된 개인 프로젝트입니다. **한정된 재고를 선착순으로 판매하는 시스템**을 구현하여, 대규모 트래픽 상황에서도 안정적이고 정확하게 작동할 수 있도록 개발되었습니다.

초기에는 모놀리식 구조로 설계되었으나, 특정 서비스에 트래픽이 몰릴 걸 고려해서 서비스 별 스케일 아웃을 하기 위해 **마이크로서비스 아키텍처(MSA)로 전환**하여 유저 관리, 티켓 관리, 주문 관리 서비스를 독립적으로 운영할 수 있도록 설계하였습니다.

<br>

## 📅 일정

**1차 완성 기간** : 2024.10.16 ~ 2024.11.16 (4주)

<br>

## 🛠 개발 환경

- Back-end : Java 21, Spring Boot 3.3.5, Spring Data JPA, Spring Security
- Database : MySQL, Redis
- infra : Docker, Docker compose, Apache Kafka
- tool : Notion, GitHub

<br>

## ⚙ 실행

```
docker compose up -d
```

<br>

## 🏗 프로젝트 아키텍처
![아키텍처](https://github.com/user-attachments/assets/837cc05b-5983-4909-ae08-f4fcd9bee7b2)

<br>

## 🏷 ERD
![ERD](https://github.com/user-attachments/assets/19bcdbb0-d486-4b9e-b52d-9c0e9b5b4823)

<br>

## 🎯 주요 기능

**유저 관리 (User Service)**

- 이메일 인증 기반 회원가입 및 개인정보 암호화 저장
- JWT를 활용한 로그인/로그아웃 및 모든 기기에서 로그아웃 기능

**티켓 관리 (Ticket Service)**

- 티켓 리스트 조회 및 상세 정보 제공

**주문 관리 (Order Service)**

- 티켓 주문 및 결제 처리
- 마이페이지에서 주문 내역 조회 및 주문 취소
- 관람일 기준 환불 정책 적용
- 장바구니 기능

<br>

## 🗂 API 문서

[놀이공원 티켓 구매 사이트 API 명세 (POSTMAN)](https://documenter.getpostman.com/view/32408353/2sAY55ZHJX)

<br>

## 🔥 성능 최적화

<details><summary>
Redis 캐싱을 통한 결제 처리 속도 66% 향상

</summary>

### 문제 상황
결제 프로세스에서 부하 테스트 결과, DB에 대한 반복적인 요청이 발생하여 처리 속도가 저하되는 문제가 있었습니다. 특히, 대량 트래픽 상황에서 DB 부하가 증가하며 결제 성공률에 영향을 미칠 가능성이 있었습니다.

### 해결을 위한 방법

**DB 최적화**  
- DB에서 인덱싱 최적화, 쿼리 튜닝, 파티셔닝 등으로 응답 속도를 개선

- DB 부하를 근본적으로 해결하지 못하며 한계가 있음

**Redis 캐싱 도입**  
- Redis에 자주 조회되는 데이터를 캐싱하여 DB 요청을 최소화하고 처리 성능 개선
  
### 결과
Redis에 재고 데이터를 캐싱하여 로컬 환경에서 재고 조회 응답 시간을 600ms 에서 205ms로 66% 감소시켰습니다.
결제 프로세스의 처리 속도가 향상되었으며, 대량 트래픽 상황에서도 안정적인 성능을 유지할 수 있었습니다.

![스크린샷 2024-11-26 135155](https://github.com/user-attachments/assets/36ac805a-938a-4130-a257-f741b35892d3) | ![스크린샷 2024-11-26 144300](https://github.com/user-attachments/assets/09bad03b-c344-40be-8492-f24ee1c7b702)
---|---|


### Redis 캐싱 이후의 확장 방안
현재 Redis 캐싱을 활용하여 결제 프로세스 성능을 최적화했지만, 트래픽 증가로 인해 Redis와 DB 부하가 다시 증가할 경우 사용할 방법입니다.

- Redis의 기본 캐싱으로 해결 가능한 트래픽 한계를 초과할 경우, Redis 클러스터나 샤딩을 통한 확장을 우선적으로 고려할 예정입니다.

- 트래픽 분산이나 이벤트 기반 처리가 필요할 경우, Kafka와 CQRS 패턴을 도입하여 읽기와 쓰기를 분리할 수도 있습니다.

- DB 부하가 다시 증가할 경우, DB 리플리케이션과 샤딩을 통해 병렬 처리를 강화합니다.

<br>

</details>



<details><summary>
MSA 도입으로 확장성과 안정성 확보
</summary>

### 모놀리식 구조에서 MSA로의 전환 배경

초기 프로젝트는 모놀리식 아키텍처로 구축되었습니다.
모놀리식 구조는 개발 속도와 초기 기능 구현에는 유리했지만, 일부 서비스에 트래픽이 집중될 경우 전체 시스템 성능에 영향을 미치는 한계가 있었습니다. 특히, 티켓 구매와 같은 특정 기능에서 트래픽이 폭증할 것을 예상했으며, 이를 처리하기 위해 개별 서비스의 독립적인 스케일아웃이 필요하다고 판단했습니다.

### 결과
- MSA 도입으로 트래픽 집중이 예상되는 서비스만 스케일아웃하여 인프라 자원을 효율적으로 사용하고, 대규모 트래픽에도 안정적으로 대응할 수 있었습니다.

- 장애 격리를 통해 개별 서비스 장애가 전체 시스템에 영향을 미치지 않아, 시스템 안정성이 크게 강화되었습니다.

- 독립적인 배포 및 개발로 인해 유지보수가 용이해지고, 새로운 기술 도입 및 기능 확장이 쉬워졌습니다.

</details>


<details><summary>
API Gateway와 Spring Cloud를 활용한 성능 최적화
</summary>

### 기술 선택의 이유

**Eureka를 활용한 서비스 디스커버리**  
MSA 환경에서는 각 서비스가 동적으로 확장되거나 위치가 변경될 수 있기 때문에, Eureka 서버를 활용해 서비스 등록과 탐색을 자동화함으로써, 서비스 간 통신을 동적으로 처리할 수 있는 구조를 구현했습니다. 서비스 위치 변경이나 장애 발생 시에도 자동으로 대체 서비스를 탐색하여 안정적인 요청 처리를 가능하게 했습니다.

**Ribbon을 활용한 클라이언트 사이드 로드 밸런싱**  
트래픽 분산을 최적화하기 위해 Ribbon을 사용해 클라이언트 사이드 로드 밸런싱을 구현했습니다. 이를 통해 각 서비스의 부하를 분산하여 트래픽이 집중되는 상황에서도 시스템이 안정적으로 작동할 수 있도록 설계했습니다. Ribbon은 Eureka와 통합되어 동적으로 서비스 인스턴스를 탐색하고, 가장 적합한 인스턴스에 요청을 전송합니다.

**Resilience4j 서킷 브레이커를 통한 장애 확산 방지**  
서비스 간 호출이 실패하거나 지연될 경우, 장애가 다른 서비스로 확산되지 않도록 Resilience4j 서킷 브레이커를 도입했습니다. 서킷 브레이커는 일정한 실패 임계치를 초과할 경우 요청을 차단하고, 시스템 복구 후 정상적으로 호출이 가능하도록 설계되었습니다. 

### 효과와 성능 개선

**트래픽 분산 최적화**
Ribbon을 활용한 클라이언트 사이드 로드 밸런싱으로 트래픽이 고르게 분산되어, 서비스 과부하를 방지하고 요청 처리 속도를 향상시켰습니다.

**서비스 장애 복원력 강화**  
Eureka와 Resilience4j를 조합하여 서비스 장애 시 대체 인스턴스를 탐색하거나, 서킷 브레이커로 장애 확산을 방지하여 시스템의 복원력을 높였습니다.

**시스템 안정성 확보**  
동적으로 서비스 디스커버리와 로드 밸런싱이 이루어져, 확장성 있는 트래픽 처리 구조를 구축했습니다.
서킷 브레이커를 통해 장애가 발생해도 빠르게 요청 흐름을 차단하여 전체 시스템의 안정성을 유지했습니다.

</details>


<details><summary>
MSA 환경에서 서비스 간 동기 호출(OpenFeign)과 비동기 호출(Kafka)의 활용
</summary>

### 기술 선택의 이유
**OpenFeign(동기 호출)**  
- MSA 환경에서는 각 서비스가 독립적인 데이터베이스를 가지고 있어, 다른 도메인의 데이터를 활용할 때 RESTful API 호출이 필수적입니다. 

- OpenFeign은 인터페이스 기반으로 구현이 간단하며, RESTful API 호출을 효율적으로 처리할 수 있어 개발과 유지보수에도 도움이 되었습니다.

- 주문 서비스에서 티켓 서비스의 데이터를 실시간으로 가져와 주문 유효성을 검증하는 데 사용했습니다. 

**Kafka(비동기 호출)**

- 재고 감소와 같은 작업은 주문 완료 후 트랜잭션 외부에서 처리해야 하며, 대량의 트래픽 환경에서도 안정적으로 작동할 필요가 있었습니다. 

- Kafka는 대규모 데이터를 실시간으로 스트리밍하면서도 내구성과 확장성을 제공하여, 이러한 재고 감소 이벤트 처리에 적합한 선택이었습니다.

- 주문 서비스는 Kafka를 통해 재고 감소 이벤트를 비동기로 전송하고, 티켓 서비스는 이를 소비하여 데이터베이스를 업데이트하였습니다. 

- 이 과정에서 주문 생성과 재고 관리 작업이 분리되어 주문 처리 속도와 시스템 안정성이 크게 향상되었습니다.

### 효과와 성능 개선
- Kafka를 활용한 비동기 호출로 재고 감소 작업이 주문 프로세스와 분리되어 동시성 문제를 방지했습니다.

- 주문 생성과 재고 관리 작업이 병렬로 실행되도록 설계되었으며, 대량 트래픽 상황에서도 안정적인 동작을 보장했습니다.
-  Kafka의 확장 가능한 아키텍처를 통해 대규모 트래픽 환경에서도 안정적인 메시징과 데이터 처리가 가능합니다.

</details>



<details><summary>
Custom Argument Resolver로 유저 정보 처리
</summary>

### 문제 상황
MSA 환경에서 JWT 검증과 유저 정보를 처리하는 로직이 서비스별로 중복되어 있었습니다.
각 서비스에 Security 설정을 추가하고, JWT 검증을 개별적으로 처리하는 방식은 코드의 복잡성을 증가시키고, 성능 저하를 유발했습니다.
또한, 유저 정보가 여러 서비스에서 일관되지 않게 처리될 가능성이 있어 데이터 정합성을 유지하기 어려웠습니다.

### 해결 방법
- Custom Argument Resolver를 도입하여 유저 정보를 간편하고 일관되게 처리할 수 있도록 설계했습니다.
- API Gateway에서 JWT를 검증하고, 유저 정보를 HTTP 헤더로 전달하여 각 서비스에서 별도로 JWT를 검증할 필요가 없도록 했습니다.
- 서비스 단에서는 Custom Argument Resolver를 통해 HTTP 요청에서 유저 정보를 추출하고, 이를 컨트롤러에서 바로 사용할 수 있도록 구현했습니다.

### 사용 이유와 효과
- JWT 검증 로직이 API Gateway로 집중됨에 따라 각 서비스에서 중복되는 Security 설정과 인증 로직을 제거했습니다.
- 서비스 단에서는 Security 필터를 실행하지 않고 HTTP 헤더에서 유저 정보를 간단히 추출하므로, 요청 처리 속도가 개선되었습니다.
- 각 서비스는 유저 정보를 처리하는 데 집중하고, 인증에 대한 책임은 Gateway에 맡겨 책임 분리가 명확해졌습니다.
- Custom Argument Resolver를 통해 유저 정보를 간단히 매개변수로 받을 수 있으므로, 컨트롤러 코드가 간결해지고 가독성이 향상되었습니다.

```java
    @GetMapping
    public ResponseEntity<List<OrderDto>> readAllOrdersByUser(UserInfo userInfo){
        List<OrderDto> orderList = orderService.readAllOrdersByUser(userInfo.username());
        return ResponseEntity.ok(orderList);
    }
```

</details>

<br>


## 🔫 트러블 슈팅

<details><summary>
동시성 문제 해결 및 결제 프로세스 최적화
</summary>

### 문제 상황
결제 프로세스에서 **동시성 문제**로 인해 여러 사용자가 동일한 재고를 동시에 구매하려는 경우, 재고 초과 소진 또는 실패가 발생하는 문제가 있었습니다.

### 해결을 위한 대안

**비관적 락 :** 락으로 인해 성능 저하 발생 가능. 락 대기 시간이 길어질 경우 병목 현상이 심화되므로 제외.

**낙관적 락 :** 적은 재고에 많은 사용자가 몰리는 상황에서 재고 충돌 빈도가 높아 적합하지 않음.

**분산 락 :** 락 관리의 복잡성과 추가적인 성능 오버헤드 발생 가능성. 간단한 재고 감소 로직에 과도하다고 판단.

**Redis + Lua 스크립트 (원자적 연산) :**

- 락 없이 원자성 보장 가능. Redis의 높은 성능을 활용해 병목 현상 없이 데이터 정합성 유지.
- **선택 이유**: 재고 차감 로직이 단순하며, 높은 동시성 환경에서도 성능을 보장할 수 있다고 판단.

**Kafka를 활용한 비동기 처리 :**
 - 결제 완료 시 DB에 최종 재고 반영을 비동기로 처리.
- 트래픽 증가에도 안정적으로 이벤트를 처리하며, 시스템 확장성과 장애 복구 기능 제공.
- **선택 이유**: 이벤트 기반의 비동기 처리를 통해 DB 부담을 줄이고 안정성을 강화.

### 선택한 방법 :
- 최종적으로 Redis와 Lua 스크립트를 활용한 원자적 연산과 Kafka를 활용한 비동기 처리를 조합하여 동시성 문제를 해결했습니다. 
- Redis와 Lua 스크립트를 사용하여 재고 감소 연산을 원자적으로 처리함으로써, 여러 사용자가 동시에 재고를 구매하려고 시도할 때 발생할 수 있는 충돌 문제를 방지했습니다. Pending 상태에서 임시로 재고를 예약하여 결제 완료 전까지 재고 초과 소진을 방지했습니다.
- Kafka를 활용하여 결제 완료 후 최종적으로 데이터베이스에 재고를 반영하는 작업을 비동기적으로 처리했습니다.

<br>

</details>

<details><summary>
API Gateway 통신 문제 해결

</summary>

### 문제 상황

MSA 환경에서 모든 요청이 API Gateway를 통해 전달되는데, 내부 서비스 간 호출에도 JWT 검증이 적용되어 불필요한 인증 과정으로 인해 성능이 저하되었습니다. 
또한, 인증이 필요 없는 요청에서도 검증 필터를 통과해야 하며, 이로 인해 처리 속도가 느려지고 401 Unauthorized 에러가 발생하는 문제가 있었습니다.

### 해결 방법
- JWT 검증이 필요 없는 요청은 검증 필터를 우회하도록 설정했습니다. 
 
- 내부 서비스 간 호출은 명시적으로 /internal 경로를 통해 처리되도록 설계하여, 해당 경로는 인증 없이 접근 가능하도록 설정했습니다.

</details>



<details><summary>
Refresh Token을 활용한 중복 로그인 허용 및 로그아웃 구현
</summary>

### 문제 상황
- 동일 계정으로 여러 기기에서 로그인할 경우, 세션 관리가 통합적으로 이루어져 중복 로그인이 불가능한 구조였습니다.

- 티켓 구매가 중요한 사이트 특성상, 사용자가 여러 기기 또는 브라우저 창에서 로그인 상태를 유지하며 필요한 작업을 수행할 수 있도록 중복 로그인 기능이 필수적이라고 판단했습니다.

- 또한, 비밀번호 변경과 같은 상황에서는 모든 기기에서 일괄적으로 로그아웃할 수 있는 기능도 필요했습니다.

### 해결 방법
- Refresh Token에 sessionId를 포함하여 각 기기를 고유하게 구분하도록 설계했습니다. 이를 통해 동일 계정으로 여러 기기에서 독립적인 세션으로 중복 로그인이 가능해졌습니다.

- 로그아웃 요청 시 해당 sessionId를 기준으로 특정 기기에서만 로그아웃되도록 구현했습니다.

- 비밀번호 변경과 같은 상황에서는 사용자 계정과 관련된 모든 sessionId를 블랙리스트에 등록하여 모든 기기에서 로그아웃되도록 처리했습니다.
</details>


<br>


## 💭 추가 개발 계획
